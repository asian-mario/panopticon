use bevy::prelude::*;use bevy::prelude::*;

use bevy_prototype_lyon::prelude::*;use bevy_prototype_lyon::prelude::*;

use crate::core::{use crate::core::{

    components::*,    components::*,

    province::ProvinceDef,    province::ProvinceDef,

    types::CountryTag,    types::CountryTag,

};};



const PROVINCE_RADIUS: f32 = 20.0;const PROVINCE_RADIUS: f32 = 20.0;

const HOVER_OUTLINE_WIDTH: f32 = 2.0;const HOVER_OUTLINE_WIDTH: f32 = 2.0;



pub fn spawn_province_markers(pub fn spawn_province_markers(

    mut commands: Commands,    mut commands: Commands,

    provinces: Vec<ProvinceDef>,    provinces: Vec<ProvinceDef>,

) {) {

    for province in provinces {    for province in provinces {

        let pos = province.pos;        let pos = province.pos;

                

        // Create circle shape        // Create circle shape

        let circle = shapes::Circle {        let circle = shapes::Circle {

            radius: PROVINCE_RADIUS,            radius: PROVINCE_RADIUS,

            center: Vec2::new(pos.x as f32, pos.y as f32),            center: Vec2::new(pos.x as f32, pos.y as f32),

        };        };



        let owner_tag: CountryTag = "GER".parse().unwrap();        commands.spawn(ProvinceBundle {

        let base_color = get_country_color(&owner_tag);            marker: ProvinceMarker { id: province.id.into() },

            ownership: ProvinceOwnership {

        commands.spawn(ProvinceBundle {                owner: "GER".parse().unwrap(), // Default for testing

            marker: ProvinceMarker { id: province.id.into() },                controller: "GER".parse().unwrap(),

            ownership: ProvinceOwnership {            },

                owner: owner_tag,            hoverable: Hoverable { hovered: false },

                controller: owner_tag,            selectable: Selectable { selected: false },

            },            spatial: SpatialBundle::from_transform(

            hoverable: Hoverable { hovered: false },                Transform::from_xyz(pos.x as f32, pos.y as f32, 0.0)

            selectable: Selectable { selected: false },            ),

            spatial: SpatialBundle::from_transform(        })

                Transform::from_xyz(pos.x as f32, pos.y as f32, 0.0)        .insert(ShapeBundle {

            ),            path: GeometryBuilder::build_as(&circle),

        })            ..default()

        .insert(ShapeBundle {        })

            path: GeometryBuilder::build_as(&circle),        .insert(Fill::color(get_country_color(&"GER".parse().unwrap())))

            ..default()        .insert(Stroke::new(Color::WHITE, HOVER_OUTLINE_WIDTH));

        })    }

        .insert(Fill::color(base_color))}

        .insert(Stroke::new(Color::WHITE, HOVER_OUTLINE_WIDTH));

    }pub fn update_province_hover(

}    mut provinces: Query<(&Transform, &mut Hoverable, &mut Stroke)>,

    camera: Query<(&Camera, &GlobalTransform)>,

pub fn update_province_hover(    window: Query<&Window>,

    mut provinces: Query<(&Transform, &mut Hoverable, &mut Stroke)>,) {

    camera: Query<(&Camera, &GlobalTransform)>,    if let Ok(window) = window.get_single() {

    window: Query<&Window>,        if let Some(cursor_pos) = window.cursor_position() {

) {            let (camera, camera_transform) = camera.single();

    if let Ok(window) = window.get_single() {            

        if let Some(cursor_pos) = window.cursor_position() {            if let Some(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) {

            let (camera, camera_transform) = camera.single();                for (transform, mut hoverable, mut stroke) in provinces.iter_mut() {

                                let province_pos = transform.translation.truncate();

            if let Some(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) {                    let distance = world_pos.distance(province_pos);

                for (transform, mut hoverable, mut stroke) in provinces.iter_mut() {                    

                    let province_pos = transform.translation.truncate();                    let is_hovered = distance < PROVINCE_RADIUS;

                    let distance = world_pos.distance(province_pos);                    hoverable.hovered = is_hovered;

                                        

                    let is_hovered = distance < PROVINCE_RADIUS;                    stroke.color = if is_hovered { Color::YELLOW } else { Color::WHITE };

                    hoverable.hovered = is_hovered;                }

                                }

                    stroke.color = if is_hovered { Color::YELLOW } else { Color::WHITE };        }

                }    }

            }}

        }

    }pub fn handle_province_selection(

}    mut provinces: Query<(&mut Selectable, &Hoverable, &mut Fill, &ProvinceOwnership)>,

    buttons: Res<Input<MouseButton>>,

pub fn handle_province_selection() {

    mut provinces: Query<(&mut Selectable, &Hoverable, &mut Fill, &ProvinceOwnership)>,    if buttons.just_pressed(MouseButton::Left) {

    buttons: Res<Input<MouseButton>>,        for (mut selectable, hoverable, mut fill, ownership) in provinces.iter_mut() {

) {            if hoverable.hovered {

    if buttons.just_pressed(MouseButton::Left) {                selectable.selected = !selectable.selected;

        for (mut selectable, hoverable, mut fill, ownership) in provinces.iter_mut() {                

            if hoverable.hovered {                // Set color based on owner + selection

                selectable.selected = !selectable.selected;                let base_color = get_country_color(&ownership.owner);

                                fill.color = if selectable.selected {

                // Set color based on owner + selection                    base_color.lerp(Color::WHITE, 0.2)

                let base_color = get_country_color(&ownership.owner);                } else {

                let mut adjusted_color = base_color;                    base_color

                                };

                // Lighten the color when selected            }

                if selectable.selected {        }

                    adjusted_color = Color::rgb(    }

                        (base_color.r() + 0.2).min(1.0),}

                        (base_color.g() + 0.2).min(1.0),

                        (base_color.b() + 0.2).min(1.0),fn get_country_color(tag: &CountryTag) -> Color {

                    );    match tag.0.as_str() {

                }        "GER" => Color::rgb(0.2, 0.2, 0.7), // German blue

                        "FRA" => Color::rgb(0.2, 0.7, 0.2), // French green

                fill.color = adjusted_color;        "POL" => Color::rgb(0.7, 0.2, 0.2), // Polish red

            }        _ => Color::GRAY,

        }    }

    }}
}

fn get_country_color(tag: &CountryTag) -> Color {
    match tag.as_str().as_str() {
        "GER" => Color::rgb(0.2, 0.2, 0.7), // German blue
        "FRA" => Color::rgb(0.2, 0.7, 0.2), // French green
        "POL" => Color::rgb(0.7, 0.2, 0.2), // Polish red
        _ => Color::GRAY,
    }
}